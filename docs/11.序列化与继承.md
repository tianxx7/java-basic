## 1.父类实现了Serializable接口后如何不修改父类的情况下让子类不可序列化

这个题目违反了里氏替换原则(子类对象可以无条件的替换父类对象), 不过面试官可能是想考察序列化的自定义操作.

## 2.子类实现序列化接口与父类实现序列化接口有什么区别吗?

子类实现Serializable接口而父类未实现时,父类不会被序列化,也不会报序列化错误,但是如果父类没有默认构造方法,则在反序列化时出异常,父类实现序列化则子类会自动实现序列化而不需要显示实现Serializable接口

引导出一个新问题,序列化与反序列化时子类和父类构造方法是怎么调用的

序列化中子类和父类构造方法的调用规则如下:

序列化时子类递归调用父类的构造函数,反序列化作用于子类对象时如果其父类没有实现序列化接口则其父类的默认无参构造函数会被调用,如果父类实现了序列化接口则不会调用构造方法,

所以要想将父类对象也序列化就需要让父类也实现Serializable接口,

如果父类没有实现就需要有默认构造方法,因为在父类没有实现Serializable接口时虚拟机是不会序列化父对象的,而一个Java对象构造必须先有父对象才有子对象,反序列化也不例外,所以反序列化是为了构造父对象则只能调用父类的额无参构造函数作为默认的父对象,故当我们取父对象的变量值时都是无参构造方法中的初始化的值.































