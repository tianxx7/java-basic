## 1.Java常见内部类有几种,说说其特征

静态内部类,成员内部类,方法内部类(局部内部类),匿名内部类

- 静态内部类是定义在另一个类里面用static修饰的class的类,静态内部类不需要依赖外部类(与类的静态成员属性类似)且其无法使用外部类的非static属性或者方法(因为可以在没有外部类的情况下直接创建静态内部类)
- 成员内部类是没有用static修饰且定义在外部类类体中的类,是最普通的内部类,可以看作是外部类的成员,可以无条件的访问外部类的所有成员属性和方法(包括private成员和静态成员),而外部类无法直接访问成员内部类的成员和属性,要想访问必须得先创建一个成员内部类的对象然后通过指向这个对象的引用来访问,当成员内部类拥有和外部类同名的成员变量或者方法时会发生隐藏现象(即默认情况下访问的是内部类的成员,如果需要访问外部类的同名成员需要通过OutClass.this.xxx形式),成员内部类的class前面可以有private等修饰符存在
- 方法内部类(局部内部类)是定义在一个方法里面的类,和成员内部类区别在于方法内部类的访问仅限于方法内,方法内部类就像是方法里面的一个局部变量一样,所以其类class前面是不能有public,protected,private,static修饰符的,也不可以在此方法外对其实例化使用
-  匿名内部类是一种没有构造器的类(实质是继承类或者实现接口的子类内名对象),由于没有构造器所以匿名内部类的使用范围有限,大部分匿名内部类用于接口回调,匿名内部类在编译的时候系统自动起名为OutClass$1.class一般匿名内部类用于继承其他类或实现接口且不需要增加额外方法的场景,匿名内部类访问外部类的成员属性需要添加final修饰(1.8开始可以不用)

## 2.为什么1.8前方法内部类和匿名内部类访问局部变量和形参需要final

1.8一下,因为对于局部变量或者形参的作用域是方法内,当方法结束时局部变量或者形参就要随之消失,而匿名内部类或者方法内部类的生命周期又没有结束,匿名内部类或者方法内部类如果想继续使用方法的局部变量就需要一些手段,所以Java在编译匿名内部类或者方法内部类时就有一个规定来解决生命周期问题,即如果访问外部类方法的局部变量值在编译期能确定则直接在匿名内部类或者方法内部类里面创建一个常量拷贝,如果访问外部类方法的局部变量值无法在编译期确定则通过构造器传参的方式来对拷贝进行初始化赋值.

由此说明在匿名内部类或者方法内部类中访问的外部类方法的局部变量或者形参是内部类自己的一份拷贝,和外部类的局部变量或者形参不是一份,所以如果在匿名内部类或者方法内部类对变量做修改操作就一定会导致数据不一致性(外部类的参数不会跟着被修改,应用类型仅是引用,值修改不存在问题),为了杜绝数据不一致导致的问题Java就要求使用final来保证.在Java1.8开始可以不加,系统会默认添加

## 3.下面说法

内部类不能有自己的成员方法和成员变量  ×

内部类可以用abstract修饰符定义为抽象类,也可以用private或protected定义  √ 想想ReentryLock

内部类可作为其他类的成员,而且可以访问它所在类的成员  √

除static内部类外,不能直接在内部类中声明static成员(static常量除外) √

##  4.成员内部类的子类应该怎样编写

成员内部类的继承语法格式要求继承引用方法为OuterClass.Inner形式且继承类的构造器中必须有指向外部类对象的引用,并通过这个引用调用super(),其实这个要求就是因为成员内部类默认持有外部类的引用,外部类不先实例化则无法实例化自己.

## 5.开发中使用Java匿名内部类有那些需要注意的事项

- 使用匿名内部类时必须是继承一个类或实现一个接口(二者不可兼得只能继承一个类或者实现一个接口)
- 匿名内部类中是不能定义构造函数的,如需初始化可以通过构造代码块处理
- 匿名内部类中不能存在任何静态成员变量和静态方法
- 匿名内部类为局部内部类,所以局部内部类的所有限制同样对匿名内部类有效
- 匿名内部类不能是抽象类,必须要实现继承的类或者接口的所有抽象方法
- 匿名内部类无法通过构造方法初始化,所以我们只能通过构造代码块进行初始化

## 6.Java中内部类有什么好处

- 内部类可以很好的实现隐蔽,最小开放原则
- 内部类拥有外部类的访问权限,通过这一特性可以比较好的处理类之间的关联性
- 通过内部类可以实现多重继承,Java默认是单继承

























