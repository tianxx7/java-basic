## 1.说说JDK1.8中HashMap是如何扩容的,与JDK1.7有什么区别?

JDK1.7扩容:

1.7扩容过程就是一个取出数组元素(实际数组索引位置上的每个元素是每个独立单向链表的头部,也就是法神Hash冲突后最后一个放入的冲突元素,头插法)然后遍历以该元素为头的单向链表元素,依据每个被遍历元素的hash值计算其在新的数组中的下标,然后进行交换(即原来hash冲突的单向链表尾部变成了扩容后单向链表的头部,尾部最后取出,头插法,变头部)

JDK1.8扩容:

数组扩容长度是2倍的关系,所以对于假设初始tableSize=4要扩容到8来说就是0100到1000的变化,在扩容中只用判断原来的hash值与左移动一位按位与操作是0是1就行,0的话索引不变,key的hash值0101,长度是4是

0101&0011,放[1]上取决于后两位,当扩容后,key的位置是否变化取决于新增加的一位的值,新增加的一位是旧的table.length与key的hash相与运算,为0,则hash索引位置不变,为1,则原索引加上扩容前数组的长度.

JDK1.7中扩容操作时hash冲突的数组索引处的旧链表元素扩容到新数组时如果扩容后索引位置在新数组的索引位置与原数组中索引位置相同,,则链表元素会发生倒置,

JDK1.8不会链表倒置























