## 1.为什么Java泛型要通过擦除来实现?擦除有什么坏处或者说代价?

可以说Java泛型的存在就是一个不得已的妥协,正是这种妥协导致Java泛型混乱.

Java之所以通过擦除来实现泛型机制其实是为了兼容性考虑,只有这样才能让非泛化代码到泛化代码的转变过程建立在不破坏现有类库的实现上,

正是因为这种兼容也带来了一些代价,譬如泛型不能显示地引用运行时类型地操作(如向上向下转型,instanceof操作等),所有关于参数地信息都丢失了,所以任何时候使用泛型都要提醒自己背后真实擦除类型到底是什么;此外擦除和兼容导致了使用泛型并不是强制地

## 2.Java泛型擦除的理解和带来的问题认识?

Java的泛型是伪泛型,因为在编译期间所有的泛型信息都会被擦除,所以我们可以通过反射add方法向Integer的泛型列表添加字符串,因为编译后都是Object.

泛型擦除具体来说就是在编译成字节码首先进行类型检查,接着进行类型擦除,如果类型擦除和多态性发生冲突时,就在子类中生成桥接方法解决.接着如果调用泛型方法的返回类型被擦除则在调用该方法时插入强制类型转换.

擦除前的类型检查是针对引用的(声明),用这个引用调用泛型方法就会对这个引用调用的方法进行类型检测而无关它真正引用的对象.

先检查后擦除带来的另一个问题就是泛型中参数化类型无法支持继承关系,因为泛型的设计初衷就是为了解决Object类型转换的弊端而存在的,如果泛型中参数化类型支持继承操作就违背了设计的初衷而继续回到原始的Object类型传唤弊端.

另一个问题是泛型读取时会进行自动类型传唤问题,所以如果调用泛型方法的返回类型被擦除则在调用该方法时插入强制类型转换

泛型类型参数不能是基本类型,因为类型擦除后是Object,而Object是引用类型而不是基本类型

擦除带来的另个问题是无法进行具体泛型参数类型的运行时类型检查,我们不能抛出也不能捕获泛型类的对象

Java中不能创建一个确切类型的泛型类型的数组,除非是采用通配符的方式且要做显式类型转换

























