## 1.HashMap中的key如果是Object则需要实现那些方法

hashCode方法和equals方法

hashCode方法用来计算Entry在数组中的index索引位置,equals方法用来比较数组指定index索引位置上链表的结点Entry元素是否相等,否则由于hashCode方法实现不恰当会导致严重的hash碰撞,从而使HashMap会退化成链表结构而影响性能

## 2.为什么HashMap中String,Integer这样的包装类适合作为key

因为String,Integer等包装类是final类型的,具有不可变性,而且已经重写了equals和hashCode方法.不可变性保证了计算hashCode后键值的唯一性和缓存特性,不会出现放入和获取时哈希码不同的情况且读取哈希值的高效性

## 3.HashMap的底层原理

向HashMap中put元素时,根据key的hash值得到这个Entry元素在数组中的位置,然后把这个Entry元素放到对应的位置中,如果这个Entry元素所在的位置上已经存放有其他元素就在同一个位置上的Entry元素以链表性质存放,新加入的放链表头部

从HashMap中get  Entry元素时先计算key的hashcode,找到数组中对应位置的某一Entry,然后通过key的equals方法在对应位置的链表中找到需要的Entry,所以HashMap是数组和链表的结合,另外,HashMap中key和value都允许为null,key为null的键值对永远都存放在table[0]为头节点的链表中

设计缘由,数组存储区间是连续的,占用内存严重,故空间复杂度大,但二分查找时间复杂度小(O(1)),所以寻址容易而插入和删除困难,而链表存储区间离散,占用内存比较宽松,故空间复杂度小,但时间复杂度大,所以寻址困难而插入和删除容易

JDK1.8实现是数组+链表+红黑树

jdk8以前碰撞节点会在链表头部插入,而jdk8开始碰撞节点会在链表尾部插入,对于扩容操作后节点转移JDK8以前转移前后链表顺序会倒置,而jdk8中依然保持原序

## 4.HashMap基础知识

JDK中默认长度是16(安卓中HashMap默认长度是4),并且默认长度和扩容后的长度都必须是2的幂次

## 5.java1.7中HashMap扩容相关的两个经典问题

### 5.1 简单说说HashMap构造方法中initialCapacity(初始容量),loadFactor(负载因子)的理解

这两个参数对于HashMap来说很重要,直接从一定程度上决定了HashMap的性能,

initialCapacity初始容量代表了哈希表中桶的初始数量,即Entry<K,V>[] table数组的初始长度,不过特别注意,table数组的长度虽然依赖initialCapacity,但是每次都会通过roundUptoPowerOf2()方法来保证为2的幂次

loadFactory加载因子是哈希表在其容量自动增加之前可以达到多慢满的一种饱和度百分比,其衡量了一个散列表的空间的使用程度,负载因子越大表示散列表的装填程度越高,反之愈小.散列当前饱和度的计算为当前HashMap中Entry的存储个数除以当前table数组桶长度,因此当哈希表中Entry的数量超过了loadFactory负载因子*当前table数组桶长度时就会触发扩容操作

















