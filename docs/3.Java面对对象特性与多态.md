## 1.面对对象特征有那些方面

特征:继承,封装,多态,抽象

1.1 继承

继承是类的一种层次模型,其提供了一种明确表述共性的方法,类型的新类可以从现有类中继承派生,扩展基类

1.2 封装

把过程和数据包围起来,使得数据的访问只能通过已经定义的接口,保证对象访问的隐私性和可靠性

1.3 多态

对象在不同时刻表现出来的多种状态,是一种编译时期和运行时期状态不一致的现象,多态包括参数化多态和包含多态性

重点:多态的实现

## 2.Java重载和重写是什么,有什么区别

重载是让类以统一的方式处理不同类型数据的一种手段,实质表现就是多个具有不同的参数个数或者类型的同名函数,同时存在于同一个类中,是一个类中多态性的一种表示

重写是父类与子类之间的多态性,实质是对父类的函数进行重新定义,如果在子类中定义某方法与父类有相同的名称和参数则方法被重写,不过子类函数的访问权限不能小于父类,

重写规则:

参数列表必须完全与被重写的方法相同,否则不能称其为重写而是重载,;返回类型必须一直与被重写的方法相同,访问修饰符的限制一定要大于等于被重写方法的访问修饰符,重写方法一定**不能**抛出新的检查异常.或者比重写方法申明更宽泛的检查型异常,可以抛出父类声明异常的子类异常

## 3.下面程序有问题吗,结果是什么

```
public class Demo {
    public static void main(String[] args) {
        Test obj  = null;
        /*
        * foo called
        * return called
        * */
        System.out.println(obj.foo());
    }
}

class Test{
    public static String foo(){
        System.out.println("foo called");
        return "return called";
    }
}
```

jvm内存里有栈区,堆区,栈区主要用来存放基础类型数据和局部变量,堆区主要存放new出来的对象,在堆区又有一个叫做方法区的内存区域用来存放常量,static变量和static方法,还有类的信息,static的变量和方法不依赖对象,即使没有创建,在类加载的时候已经存在信息了(Test在声明时就被加载了,jvm识别出是static方法就是直接调用了在方法区内存里的方法,没有报空指针异常)

## 4.java equals与hashCode相关面试题

Java对于equals方法和hashCode方法的规定是如果两个对象equals方法相等则它们的hashCode值一定要相同,如果两个对象的hashCode相同则它们的equals方法并不一定相同

hashCode的作用是为了提高在散列结果存储中查找的效率,在线性表中没有作用;只有每个对象的hash码尽可能不同才能保证散列的存取性能,事实上Object类提供的默认实现确实保证每个对象的hash码不同(在对象的内存地址基础上经过特定算法返回一个hash码).

## 5.Java中为什么重写equals方法时尽量要重写hashCode方法

自定义类重写equals方法是用来进行等值比较,重写compareTo方法是用来进行不同对象大小比较,而重写hashCode方法是为了将数据存入HashSet,HashMap,HashTable等基于哈希表的集合类时进行高效比较.

重写equals时通常有必要重写hashCode方法来维护hashCode方法的常规协定,该协定声明相等对象必须具有相等的哈希码,如果不这样做的话就会违反hashCode方法的常规约定,从而导致该类无法结合所有基于散列的集合一起正常运作

##  6.Java中静态代码块,构造代码块,构造方法的执行顺序是什么?

因为静态块作用于类级别,构造代码块和构造方法作用于对象级别,所以静态代码块是随着类的加载而被执行,只要类被加载了就会执行,而且只会加载一次,主要用于给类进行初始化;构造代码块在每次创建一个对象时就会执行一次且优先于构造函数,主要用于初始化不同对象共性的初始化内容和初始化实例环境;构造方法在每次创建一个对象时就会执行一次,同时构造方法是给特定对象进行初始化,而构造代码是给所有对象进行初始化;所以通过分析得出它们三者的执行顺序  静态代码块>构造代码块>构造方法.

**静态代码块是在类加载的初始化过程执行的**



























