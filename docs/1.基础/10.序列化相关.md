## 1.谈谈你对Java序列化与反序列化理解

序列化就是将对象转化为字节流,反序列化就是将字节流转换为对象,默认的序列化是深度序列化(即类中包含的深度嵌套其他对象引用的对象都会被序列化),**静态成员不会被默认序列化**,要让一个类支持序列化只要让这个类实现接口java.io.Serializable即可,声明实现Serializable接口后,保存读取对象就可以使用ObjectOutputStream,ObjectInputStream流,ObjectOutPutstream是OutputStream的子类,实现了ObjectOutput接口,ObjectOutput是DataOutput的子接口,增加了一个writeObject()方法将对象转化为字节流写到流中,

有时候我们对象有些字段的值可能与内存位置(hashcode),当前时间等有关,所以不想序列化这类字段(因为反序列化是没有意义的),所以我们要自定义序列化,Java提供的定制主要有transient关键字方式和实现writeObject,readObject方式及Externalizable接口readResolve,writeReplace方式,还可以将字段声明为transient后通过writeObject,readObject方法来自己保存该字段

## 2.transient关键字

对于不需要被序列化的属性就可以加上transient关键字处理,一旦属性被transient修饰就不再是对象持久化的一部分了,该属性在序列化后将呜啊获得访问,transient关键字只能修饰属性成员,属性成员如果是引用类型也需要保证实现Serializable接口,此外在Java中对象的序列化可以通过实现两种接口来实现,若实现的是Serializable接口则所有的序列化将会自动进行,若实现的是Externalizable接口则没有任何东西可以自动序列化,需要在writeExternal方法中进行手工指定所要序列化的变量,这与是否被transient修饰无关

## 3.简单说说Externalizable与Serializable有什么区别

使用该接口时序列化的细节需要我们自己去实现,另外使用Externalizable主动进行序列化时当读取对象时会调用被序列化类的无参构造方法去创建一个新的对象,然后再将被保存对象的字段值分别填充到新对象中,所以实现Externalizable接口的类必须提供一个无参public的构造方法,实现Externalizable方式时必须提供无参构造方法,且readExternal方法必须按照与writeExternal方法写入值时相同的顺序和类型来读取属性值.

## 4.Serializable序列化中自定义readObjectNoData方法有什么作用

这个方法主要用来保证通过继承扩容后对老版本的兼容性,适用场景如下:类Person被序列化到硬盘后存储为文件old.txt,接着Person被修改继承自Animal,为了保证新的Person反序列化老版本old.txt文件且Animal类的成员有默认值则可以在Animal类中定义readObjectNoData方法返回成员的默认值

## 5.writeReplace方法有什么作用

Serializable除提供了writeObject和readObject标记方法外还提供了另外两个标记方法可以实现序列化对象的替换(writeReplace和readResolve),序列化类一旦实现了writeReplace方法后则在序列化时就会先调用writeReplace方法将当前对象替换成另一个对象(该方法返回替换后的对象),接着系统将再次调用另一个对象的writeReplace方法,直到该方法不再返回另一个对象为止,程序最后将调用该对象的writeObject方法来保存该对象的状态

## 6.Java序列化中的readResolve()方法有什么用

同上Serializable除过提供了writeObject和readObject标记方法外还提供了writeReplace和readResolve,readResolve方法可以实现保护性复制整个对象,会紧挨着序列化类实现的readObject后被调用,该方法的返回值会代替原来的反序列化的对象,而原来序列化类中readObject反序列化的对象将会被立即丢弃,readObject方法在序列化单例类时尤其有用,单例序列化都应该提供readResolve方法,这样才可以保证反序列化的对象依然正常

## 7.Java序列化存储传输为什么不安全,怎么解决

因为序列化二进制格式完全编写在文档中且完全可逆,所以只需要将二进制序列化的内容转储到控制台就可以看清类及包含的内容,故序列化对象中任何private字段几乎都是以明文方式出现在序列化流中,如果我们传输的序列化数据中途被截获,截获方通过反序列化就可以获得里面的数据,甚至对里面的数据进行修改然后发送给接收方,从而产生序列化安全问题

解决方法:避免在序列化过程中传递敏感数据,可以使用关键字transient修饰敏感数据的变量,或者通过自定义序列化相关流程对数据进行签名加密机制再存储或者传输























